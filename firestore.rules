
/**
 * Core Philosophy: This ruleset enforces a security model where a single 'superAdmin'
 * has full control over managing user groups and memberships. Regular users' access is
 * scoped to the content within their assigned group.
 *
 * Data Structure: The core data is organized hierarchically under the `/user_groups/{userGroupId}` path.
 * This includes subcollections for `/users`, `/recipes`, and `/shopping_lists`, ensuring that all data
 * for a group is logically and securely co-located. Top-level collections like `/recipe_views` and
 * `/activity_logs` are used for application-wide analytics and auditing, intentionally separated from
 * the group-specific security constraints.
 *
 * Key Security Decisions:
 * - Super-Admin Control: A user with the `superAdmin` custom claim set to `true` has exclusive
 *   privileges to create, update, or delete `user_groups` and manage user memberships within them.
 * - Group Isolation: A user's primary authorization comes from their membership in a group. Users can
 *   only access data within the groups they belong to. The existence of their user document in the
 *   `/user_groups/{userGroupId}/users/{userId}` subcollection serves as proof of membership.
 * - No Group Listing: Listing all `user_groups` is explicitly disallowed to prevent enumeration of different
 *   family groups on the platform. Regular users can only read the group document they belong to.
 * - Append-Only Logs: The `/recipe_views` and `/activity_logs` collections are designed to be append-only
 *   for clients, ensuring the integrity of analytics and audit trails.
 *
 * Denormalization for Authorization:
 * - The super-admin status is checked via a custom claim (`request.auth.token.superAdmin`), avoiding
 *   any database reads to verify administrative permissions for group management.
 * - A user's group membership is determined by a fast `exists()` call on their user document within a
 *   group's `users` subcollection.
 *
 * Structural Segregation:
 * - Private Content: All collaborative data (recipes, shopping lists) is nested under `/user_groups`,
 *   inheriting strict, membership-based access controls.
 * - Public/Analytics Data: Collections like `/recipe_views` are at the top level to allow for different,
 *   more open write permissions (e.g., for guest users).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the application-wide super administrator.
     * This relies on a custom claim being set on the user's auth token.
     */
    function isSuperAdmin() {
        return isSignedIn() && request.auth.token.superAdmin == true;
    }

    /**
     * Checks if the requesting user is a member of a specific group by verifying
     * the existence of their user document in the group's `users` subcollection.
     */
    function isGroupMember(userGroupId) {
      return isSignedIn() && exists(/databases/$(database)/documents/user_groups/$(userGroupId)/users/$(request.auth.uid));
    }
    
    /**
     * Checks if a user can manage (update/delete) a resource. True if they are the
     * resource creator OR the super admin. Also verifies the resource exists.
     */
    function canManageContent(existingData) {
        return resource != null && (isOwner(existingData.userId) || isSuperAdmin());
    }


    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Manages user groups. Only the super-admin can create, update, or delete groups.
     * Members can read the details of the group they belong to, but cannot list all groups.
     * @path /user_groups/{userGroupId}
     * @allow (create) The super-admin creates a new group.
     * @deny (list) A regular user tries to list all user groups.
     * @principle Centralizes group management under a single administrative role.
     */
    match /user_groups/{userGroupId} {
      allow get: if isGroupMember(userGroupId) || isSuperAdmin();
      allow list: if false; // Prevent listing all groups
      allow create, update, delete: if isSuperAdmin();

      /**
       * @description Manages users within a group. Only the super-admin can add, update,
       * or remove users. Group members can view the list of other members.
       * @path /user_groups/{userGroupId}/users/{userId}
       * @allow (create) The super-admin adds a new user to a group.
       * @deny (delete) A regular user tries to remove another user.
       * @principle Restricts user management to the super-admin, while allowing read access for members.
       */
      match /users/{userId} {
        allow get, list: if isGroupMember(userGroupId) || isSuperAdmin();
        allow create, update, delete: if isSuperAdmin();
      }

      /**
       * @description Manages recipes within a group. Any group member can create and view recipes.
       * Only the recipe's creator or the super-admin can update or delete it.
       * @path /user_groups/{userGroupId}/recipes/{recipeId}
       * @allow (create) A member of the group creates a new recipe.
       * @deny (update) A user tries to edit a recipe they didn't create (and is not super-admin).
       * @principle Enforces collaborative access within a group, with ownership/admin rights for modification.
       */
      match /recipes/{recipeId} {
        allow get, list: if isGroupMember(userGroupId);
        allow create: if isGroupMember(userGroupId) && request.resource.data.userId == request.auth.uid && request.resource.data.userGroupId == userGroupId;
        allow update: if canManageContent(resource.data) && request.resource.data.userId == resource.data.userId && request.resource.data.userGroupId == resource.data.userGroupId;
        allow delete: if canManageContent(resource.data);
      }

      /**
       * @description Manages shopping lists within a group. Any group member can create and view lists.
       * Only the list's creator or the super-admin can update or delete the main list document.
       * @path /user_groups/{userGroupId}/shopping_lists/{shoppingListId}
       * @allow (get) A group member views a shopping list.
       * @deny (delete) A group member tries to delete a list created by another member.
       * @principle Enforces collaborative access for reads and creator/admin rights for writes.
       */
      match /shopping_lists/{shoppingListId} {
        allow get, list: if isGroupMember(userGroupId);
        allow create: if isGroupMember(userGroupId) && request.resource.data.userId == request.auth.uid && request.resource.data.userGroupId == userGroupId;
        allow update: if canManageContent(resource.data) && request.resource.data.userId == resource.data.userId && request.resource.data.userGroupId == resource.data.userGroupId;
        allow delete: if canManageContent(resource.data);

        /**
         * @description Manages items on a shopping list. Any member of the group can add,
         * update, or remove items, allowing for a fully collaborative list.
         * @path /user_groups/{userGroupId}/shopping_lists/{shoppingListId}/items/{itemId}
         * @allow (create) Any group member adds an item to the list.
         * @deny (create) A user who is not in the group tries to add an item.
         * @principle Provides open, collaborative write access for all members of the parent group.
         */
        match /items/{itemId} {
          allow read, write: if isGroupMember(userGroupId);
        }
      }
    }

    /**
     * @description Logs recipe view events, primarily for guest access analytics.
     * This collection is write-only and allows creation by anyone, including unauthenticated
     * users, to track views from shared links.
     * @path /recipe_views/{recipeViewId}
     * @allow (create) An anonymous guest user views a recipe, triggering a log write.
     * @deny (read, update, delete) Any user attempts to read or modify existing log entries.
     * @principle Secures analytics data by making it append-only and inaccessible to clients.
     */
    match /recipe_views/{recipeViewId} {
      allow read, update, delete: if false;
      allow create: if true;
    }

    /**
     * @description Logs user activities within the application. This collection is write-only
     * for any authenticated user to create log entries about their own actions.
     * @path /activity_logs/{activityLogId}
     * @allow (create) An authenticated user adds a recipe, and the client writes an accompanying log entry.
     * @deny (read, update, delete) Any user attempts to read or modify existing log entries.
     * @principle Secures audit trail data by making it append-only and inaccessible to clients.
     */
    match /activity_logs/{activityLogId} {
      allow read, update, delete: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    }
  }
}

    