
/**
 * Core Philosophy: This ruleset enforces a two-tiered administrative system.
 * 1. Super-Admin: A single user with a `superAdmin` custom claim has full control over
 *    the entire application, including creating and managing all groups and users.
 * 2. Group Admins: Each `user_group` has an `adminIds` list, designating users who can
 *    manage memberships and content within that specific group.
 *
 * Data Structure: The core data is organized hierarchically under `/user_groups/{userGroupId}`.
 * This includes subcollections for `/users`, `/recipes`, and `/shopping_lists`, ensuring that all data
 * for a group is logically and securely co-located. Top-level collections like `/recipe_views` and
 * `/activity_logs` are used for application-wide analytics and auditing.
 *
 * Key Security Decisions:
 * - Super-Admin Priority: The super-admin can perform any action, bypassing group-level admin checks.
 * - Delegated Group Administration: Users whose UIDs are in a group's `adminIds` array can manage
 *   that group's users and content.
 * - Group Isolation: A user's primary authorization comes from their membership in a group. Users can
 *   only access data within the groups they belong to. The existence of their user document in the
 *   `/user_groups/{userGroupId}/users/{userId}` subcollection serves as proof of membership.
 * - No Group Listing: Listing all `user_groups` is explicitly disallowed to prevent enumeration.
 * - Append-Only Logs: The `/recipe_views` and `/activity_logs` collections are designed to be append-only
 *   for clients, ensuring the integrity of analytics and audit trails.
 *
 * Denormalization for Authorization:
 * - The super-admin status is checked via a custom claim (`request.auth.token.superAdmin`), avoiding
 *   database reads for the highest level of permissions.
 * - A user's group admin status is determined by reading the `adminIds` field on the specific `user_group`
 *   document being accessed.
 * - A user's group membership is determined by a fast `exists()` call on their user document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the application-wide super administrator.
     * This relies on a custom claim being set on the user's auth token.
     */
    function isSuperAdmin() {
        return isSignedIn() && request.auth.token.superAdmin == true;
    }

    /**
     * Checks if the requesting user is a member of a specific group by verifying
     * the existence of their user document in the group's `users` subcollection.
     */
    function isGroupMember(userGroupId) {
      return isSignedIn() && exists(/databases/$(database)/documents/user_groups/$(userGroupId)/users/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user is an administrator of a specific group.
     * This is true if their UID is in the group's `adminIds` list.
     */
    function isGroupAdmin(userGroupId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/user_groups/$(userGroupId)).data.adminIds;
    }

    /**
     * Checks if a user has management rights over a group (either group admin or super admin).
     */
    function canManageGroup(userGroupId) {
        return isGroupAdmin(userGroupId) || isSuperAdmin();
    }
    
    /**
     * Checks if a user can manage a piece of content (update/delete). True if they are the
     * content creator, a group admin, OR the super admin.
     */
    function canManageContent(userGroupId, existingData) {
        return resource != null && (isOwner(existingData.userId) || canManageGroup(userGroupId));
    }


    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Manages user groups. Only the super-admin can create groups. Group admins
     * and the super-admin can update group details (like the name). Deletion is restricted
     * to the super-admin for safety.
     * @path /user_groups/{userGroupId}
     * @allow (create) The super-admin creates a new group.
     * @deny (list) A regular user tries to list all user groups.
     * @principle Centralizes group creation, but delegates updates.
     */
    match /user_groups/{userGroupId} {
      allow get: if isGroupMember(userGroupId) || isSuperAdmin();
      allow list: if false; // Prevent listing all groups
      allow create: if isSuperAdmin();
      allow update: if canManageGroup(userGroupId);
      allow delete: if isSuperAdmin(); // Only super-admin can delete a group

      /**
       * @description Manages users within a group. Group admins or the super-admin can add,
       * update, or remove users from the group. Regular group members can view the list of other members.
       * @path /user_groups/{userGroupId}/users/{userId}
       * @allow (create) A group admin adds a new user.
       * @deny (delete) A regular member tries to remove another user.
       * @principle Restricts user management to designated administrators.
       */
      match /users/{userId} {
        allow get, list: if isGroupMember(userGroupId) || isSuperAdmin();
        allow create, update, delete: if canManageGroup(userGroupId);
      }

      /**
       * @description Manages recipes within a group. Any group member can create and view recipes.
       * Management (update/delete) is restricted to the creator, a group admin, or the super-admin.
       * @path /user_groups/{userGroupId}/recipes/{recipeId}
       * @allow (create) A member of the group creates a new recipe.
       * @deny (update) A user tries to edit a recipe they don't own and is not an admin.
       * @principle Enforces collaborative access with layered management rights.
       */
      match /recipes/{recipeId} {
        allow get, list: if isGroupMember(userGroupId);
        allow create: if isGroupMember(userGroupId) && request.resource.data.userId == request.auth.uid && request.resource.data.userGroupId == userGroupId;
        allow update: if canManageContent(userGroupId, resource.data) && request.resource.data.userId == resource.data.userId && request.resource.data.userGroupId == resource.data.userGroupId;
        allow delete: if canManageContent(userGroupId, resource.data);
      }

      /**
       * @description Manages shopping lists within a group. Similar to recipes, any member
       * can create and view, but management is restricted.
       * @path /user_groups/{userGroupId}/shopping_lists/{shoppingListId}
       * @principle Enforces collaborative access with layered management rights.
       */
      match /shopping_lists/{shoppingListId} {
        allow get, list: if isGroupMember(userGroupId);
        allow create: if isGroupMember(userGroupId) && request.resource.data.userId == request.auth.uid && request.resource.data.userGroupId == userGroupId;
        allow update, delete: if canManageContent(userGroupId, resource.data);

        /**
         * @description Manages items on a shopping list. Any member of the group can add,
         * update, or remove items, allowing for a fully collaborative list.
         * @path /user_groups/{userGroupId}/shopping_lists/{shoppingListId}/items/{itemId}
         * @allow (create) Any group member adds an item.
         * @principle Provides open, collaborative write access for all members of the parent group.
         */
        match /items/{itemId} {
          allow read, write: if isGroupMember(userGroupId);
        }
      }
    }

    /**
     * @description Logs recipe view events, primarily for guest access analytics.
     * This collection is write-only and allows creation by anyone, including unauthenticated
     * users, to track views from shared links.
     * @path /recipe_views/{recipeViewId}
     * @allow (create) An anonymous guest user views a recipe, triggering a log write.
     * @deny (read, update, delete) Any user attempts to read or modify existing log entries.
     * @principle Secures analytics data by making it append-only and inaccessible to clients.
     */
    match /recipe_views/{recipeViewId} {
      allow read, update, delete: if false;
      allow create: if true;
    }

    /**
     * @description Logs user activities within the application. This collection is write-only
     * for any authenticated user to create log entries about their own actions.
     * @path /activity_logs/{activityLogId}
     * @allow (create) An authenticated user adds a recipe, and the client writes an accompanying log entry.
     * @deny (read, update, delete) Any user attempts to read or modify existing log entries.
     * @principle Secures audit trail data by making it append-only and inaccessible to clients.
     */
    match /activity_logs/{activityLogId} {
      allow read, update, delete: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    }
  }
}
